<resources>
    <string name="app_name">QuizApp</string>
    <string name="title_message">Software Engineering Study App</string>
    <string name="button_continue">Continue</string>
    <string name="continue_message">Click below to continue</string>
    <string name="button_viewGrades">View Grades</string>
    <string name="button_startsStudying">Start Studying</string>
    <string name="button_startQuiz">Start Quiz</string>
    <string name="blank_string_spacing"></string>
    <string name="quiz_topic2">Software Processes</string>
    <string name="quiz_topic3">Implementation</string>
    <string name="button_true">True</string>
    <string name="button_false">False</string>
    <string name="button_next">Next</string>
    <string name="button_finish">Finish</string>
    <string name="finished_quiz">You have completed all the questions</string>
    <string name="correct_answer_msg">Correct</string>
    <string name="incorrect_answer_msg">Incorrect</string>
    <string name="button_results">See Results</string>
    <string name="quiz_topic1">Introduction</string>
    <string name="topic1_question1">Software engineering is concerned with theories, methods, and tools for professional software development.</string>
    <string name="topic1_question2">Software costs almost never dominate computer system costs. The costs of hardware for a PC are usually greater than the costs of software on a PC.</string>
    <string name="topic1_question3">Software costs more to maintain than to develop, especially for systems with a long life.</string>
    <string name="topic1_question4">Software engineering prioritizes cost-effective software development.</string>
    <string name="topic1_question5">Software projects do not fail because of an increase in system complexity.</string>
    <string name="topic1_question6">Failure to use software engineering methods is a large reason for project failure.</string>
    <string name="topic1_question7">Good attributes of software deliver functionality and performance and should only be semi-maintainable, dependable, and usable.</string>
    <string name="topic1_question8">Fundamental software engineering activities only include software development and software validation</string>
    <string name="topic1_question9">Computer science is concerned with the practicalities of developing software while software engineering focuses on the theories and fundamentals.</string>
    <string name="topic1_question10">System engineering is concerned with all aspects of computer-based systems development including hardware, software, and process engineering while software engineering focuses on the more general process.</string>
    <string name="topic1_question11">Roughly 50% of software costs are development costs, 35% are testing costs, and the remaining 15% costs are miscellaneous.</string>
    <string name="topic1_question12">Stand-alone systems are only marketed to specific customers.</string>
    <string name="topic1_question13">Examples of customized products are embedded control systems, air traffic control software, and traffic monitoring systems.</string>
    <string name="topic1_question14">Generic product software is owned by the developer and customized product software is owned by the customer.</string>
    <string name="topic1_question15">Software should be written in a way that cannot be changed so that it serves its purpose for as long as it is needed.</string>
    <string name="topic1_question16">Dependable software should not cause physical or economic damage in the event of system failure.</string>
    <string name="topic1_question17">Software should use as much of system resources (like memory and processor cycles) in order to be efficient.</string>
    <string name="topic1_question18">Software should be understandable, usable, and compatible with other systems they use.</string>
    <string name="topic1_question19">Software engineering also includes project management and development of tools and methods to support software production.</string>
    <string name="topic1_question20">Software engineers should be able to produce reliable and trustworthy systems economically and quickly</string>
    <string name="topic1_question21">Writing programs as if they were a personal programming project is usually cheaper than software engineering methods.</string>
    <string name="topic1_question22">Software specification is where only the engineers define the software that needs to be produced and the constraints.</string>
    <string name="topic1_question23">Software development is when the software is designed and programmed and software validation is checked to ensure that it is what the customer requires.</string>
    <string name="topic1_question24">Software evolution allows the software to be modified to reflect changing customer and market requirements.</string>
    <string name="topic1_question25">Heterogeneity are systems required to operate as distributed systems across networks that include different types of computer and mobile devices.</string>
    <string name="topic1_question26">Existing software should be erased and replaced as businesses and society changes.</string>
    <string name="topic1_question27">Since software is intertwined with our lives, we must be able to trust that software.</string>
    <string name="topic1_question28">Stand-alone applications run on local computers, but do not include all necessary functionality and need to be connected to a network.</string>
    <string name="topic1_question29">Interactive transaction-based applications execute on remote computers and cannot be accessed by users from their own PCs or terminals.</string>
    <string name="topic1_question30">Entertainment systems are primarily for personal use and are intended to entertain the user.</string>
    <string name="topic1_question31">Systems for modeling and simulation are systems developed by scientists and engineering to model physical processes or situations.</string>
    <string name="topic1_question32">Systems should be developed with the same development process for each type of software.</string>
    <string name="topic1_question33">Never use software that has already been developed and always write new software.</string>
    <string name="topic1_question34">The Web is now a platform for running applications and organizations are increasingly developing web-based systems rather then local systems.</string>
    <string name="topic1_question35">Web-based systems are simple distributed systems and have the same fundamental principles of software engineering that are applied to any other system.</string>
    <string name="topic1_question36">Software reuse is necessary for constructing web-based systems.</string>
    <string name="topic1_question37">Web-systems should be developed and delivered all at one time.</string>
    <string name="topic1_question38">Service-oriented systems develop software components as stand-alone web services.</string>
    <string name="topic1_question39">Software engineering is an engineering discipline concerned with all aspects of software production.</string>
    <string name="topic1_question40">Fundamental notions of software are only applicable to simple types of system development.</string>
    <string name="topic2_question1">Software systems do not require a structured set of activities to be developed.</string>
    <string name="topic2_question2">All software processes involve specification, design and implementation, validation, and evolution.</string>
    <string name="topic2_question3">A software process model is an abstract representation of a process, presenting a description of a process from some particular perspective.</string>
    <string name="topic2_question4">Process descriptions are only about products (outcomes of a process activity).</string>
    <string name="topic2_question5">Plan-driven processes are processes where all of the process activities are planned in advance and progress in measured against the plan.</string>
    <string name="topic2_question6">In agile processes, once the plan is made, changes based on customer requirement are difficult to include.</string>
    <string name="topic2_question7">This is the waterfall method:</string>
    <string name="topic2_question8">The waterfall model is only used for small projects where a system is developed at one site.</string>
    <string name="topic2_question9">Incremental development processes make reducing changing customer requirements difficult.</string>
    <string name="topic2_question10">Customer feedback is easier to get when the development work is done using the incremental development process.</string>
    <string name="topic2_question11">Reuse is now the standard approach for building many types of business systems.</string>
    <string name="topic2_question12">Stand-alone application systems, collections of objects developed as a package, and web services developed to service standards are types of reusable software.</string>
    <string name="topic2_question13">Reusing software means almost no requirement compromises will need to be made for the customer.</string>
    <string name="topic2_question14">Real software processes are interleaved sequences of technical, collaborative, and managerial activities with the overall goal of completing a software system.</string>
    <string name="topic2_question15">These are the requirements of the engineering process:</string>
    <string name="topic2_question16">Software specification establishes what services are required, but constraints are part of the validation process.</string>
    <string name="topic2_question17">Software design is designing and creating specifications into an executable program.</string>
    <string name="topic2_question18">Architecture design is where the overall structure of the systems, the principal components, their relationships, and how they are distributed are identified.</string>
    <string name="topic2_question19">Database design is how to represent a database.</string>
    <string name="topic2_question20">Interface design is where all the data structures and interfaces between system components are designed.</string>
    <string name="topic2_question21">Component selection and design is searching for reusable components.</string>
    <string name="topic2_question22">Programming is a collaborative process with a standard process.</string>
    <string name="topic2_question23">Verification and validation show that a system meets requirements, but disregards customer constraints.</string>
    <string name="topic2_question24">System testing involves executing the system with test cases derived from the specification of the real data to be processed by the system.</string>
    <string name="topic2_question25">Testing stages include data structure testing, component testing, system testing, and customer testing.</string>
    <string name="topic2_question26">Software is inflexible and rarely changeable.</string>
    <string name="topic2_question27">Change is inevitable in all large software projects because of business changes, new technologies, and changing platforms.</string>
    <string name="topic2_question28">Change anticipation includes activities that can anticipate possible changes in software before significant rework is required.</string>
    <string name="topic2_question29">System prototyping is not encouraged because the system is designed quickly in order to check customer requirements.</string>
    <string name="topic2_question30">A prototype is an initial version of a system used to demonstrate concepts and try out design options.</string>
    <string name="topic2_question31">Benefits of prototyping are improved system usability, a closer match to the users’ real needs, improved design quality, improved maintainability, and reduced development effort.</string>
    <string name="topic2_question32">Prototype development should focus only on well-understood areas of the product.</string>
    <string name="topic2_question33">Prototypes should be discarded after development.</string>
    <string name="topic2_question34">Incremental delivery breaks down system delivery into smaller parts with each increment delivering part of the required functionality.</string>
    <string name="topic2_question35">Incremental development is where the system is developed in increments and each increment is evaluated before proceeding to the development of the next increment.</string>
    <string name="topic2_question36">Disadvantages of incremental delivery include difficulty receiving customer value, higher risk of project failure, and low priority system services.</string>
    <string name="topic2_question37">Processes may be structured for iterative development and delivery so that changes may be made without disrupting the system as a whole.</string>
    <string name="topic2_question38">Prototypes should continue to be used after development.</string>
    <string name="topic2_question39">You should not expect to make changes in large software projects.</string>
    <string name="topic2_question40">Component selection and design is coming up with original ideas and implementations for components.</string>
    <string name="topic3_question1">Software design and implementation is the state in software engineering where the executable software is developed.</string>
    <string name="topic3_question2">Structured object-oriented design processes involve developing a number of different system models, but only for small systems developed by different groups due to design models being an important communication mechanism.</string>
    <string name="topic3_question3">Process stages include defining context and modes of the use of the system, designing the system architecture, identifying the principal system objects, developing design models, and specifying object interfaces.</string>
    <string name="topic3_question4">Understanding the relationships between software being designed and its external environment are nonessential; focus should only be placed on the software.</string>
    <string name="topic3_question5">A system context model demonstrates a single system in the environment of the system being developed.</string>
    <string name="topic3_question6">Identifying object classes can be difficult because there is no ‘magic formula’ for object identification.</string>
    <string name="topic3_question7">Base identification on tangible things in the application domain and identify objects based on what participates in what behavior.</string>
    <string name="topic3_question8">Design models only show structural models to describe the static structure in the system in terms of object classes and relationships.</string>
    <string name="topic3_question9">Subsystem models show logical groupings of object into coherent subsystems.</string>
    <string name="topic3_question10">State machine models show the sequence of object states.</string>
    <string name="topic3_question11">Sequence models arrange objects horizontally across the top and time is represented vertically so the models read top to bottom.</string>
    <string name="topic3_question12">This is an example of a sequence diagram:</string>
    <string name="topic3_question13">Subsystem models show how the design is organized into logically related groups of objects.</string>
    <string name="topic3_question14">Other models include use-case models, aggregation models, generalization models.</string>
    <string name="topic3_question15">The following is an example of a state diagram:</string>
    <string name="topic3_question16">Class diagrams show the structure and associate of the classes and list possible state variables and possible interaction methods.</string>
    <string name="topic3_question17">Patterns and pattern languages are ways to describe mediocre practices and designs to help others reuse that experience.</string>
    <string name="topic3_question18">Observer patterns tell one object the state of other objects have changed.</string>
    <string name="topic3_question19">Factory patterns are a creational pattern and deal with object creation.</string>
    <string name="topic3_question20">Facade patterns tidy up unrelated objects that have been developed at the same time.</string>
    <string name="topic3_question21">Iterator patterns provide a standard way of accessing one element in a collection with respect to how that collection is implemented.</string>
    <string name="topic3_question22">Decorator patterns allow for the possibility of extending the functionality of an existing class at run-time.</string>
    <string name="topic3_question23">Design patterns are a way of reusing abstract knowledge about a problem and its solution.</string>
    <string name="topic3_question24">You do not need to recognize patterns in a design problem in order to use patterns in your design.</string>
    <string name="topic3_question25">Creational design patterns engineer a way to create objects rather than creating them directly.</string>
    <string name="topic3_question26">Structural design patterns compose objects to obtain new functionalities.</string>
    <string name="topic3_question27">Behavioral design patterns are concerned with communications of objects and changing their behavior at run time.</string>
    <string name="topic3_question28">The process of object-oriented design is only helpful for designing the system architecture.</string>
    <string name="topic3_question29">A limited range of different models may be produced during an object-oriented design process.</string>
    <string name="topic3_question30">Component interfaces must be defined precisely so that other objects can use them.</string>
    <string name="temp_futurefeature">This will be implemented as a feature later</string>
    <string name="studyActivityInstructions">Click above to flip over the flash card</string>
    <string name="studyAnsFalse">FALSE</string>
    <string name="studyAnsTrue">TRUE</string>
    <string name="topic4_question1">Rapid development and delivery is the least important requirement for software systems.</string>
    <string name="topic4_question2">Software has to evolve quickly to reflect changing business needs.</string>
    <string name="topic4_question3">Plan-driven development is essential for all types of systems.</string>
    <string name="topic4_question4">Agile development methods aim to radically reduce the delivery time for working software systems.</string>
    <string name="topic4_question5">Regarding agile development, program specification, design and implementation are interleaved.</string>
    <string name="topic4_question6">Agile development relies on frequent delivery of new versions for evaluation.</string>
    <string name="topic4_question7">Agile development includes frequent and extensive documentation.</string>
    <string name="topic4_question8">This is an example of Agile Software Development:</string>
    <string name="topic4_question9">Plan-driven development is based around separate development stages with the outputs to be produced at each of these stages.</string>
    <string name="topic4_question10">Plan-driven development is not planned in advance.</string>
    <string name="topic4_question11">For agile development, iteration occurs within activities.</string>
    <string name="topic4_question12">An agile development method focuses on the design rather than the code.</string>
    <string name="topic4_question13">Agile development is based on an iterative approach to software development.</string>
    <string name="topic4_question14">The aim of agile methods is to reduce overheads in the software process.</string>
    <string name="topic4_question15">One principle of agile development is to encourage customer involvement.</string>
    <string name="topic4_question16">One principle of agile development is to reject change.</string>
    <string name="topic4_question17">Extreme programming involves new versions possibly being built several times per day.</string>
    <string name="topic4_question18">Extreme programming delivers increments to customers every day.</string>
    <string name="topic4_question19">This is an example of extreme programming release cycle:</string>
    <string name="topic4_question20">Simple design is a principle of extreme programming.</string>
    <string name="topic4_question21">Large releases is a practice of extreme programming.</string>
    <string name="topic4_question22">A key practice of extreme programming is refactoring.</string>
    <string name="topic4_question23">In extreme programming, user requirements are expressed as user stories or scenarios.</string>
    <string name="topic4_question24">Refactoring is worth spending time and effort anticipating changes.</string>
    <string name="topic4_question25">Testing is not important to extreme programming.</string>
    <string name="topic4_question26">In test-driven development, tests are written as data rather than programs.</string>
    <string name="topic4_question27">In test automation, tests are written as executable components.</string>
    <string name="topic4_question28">Test automation components should be interleaved.</string>
    <string name="topic4_question29">Pair programming involves programmers working in pairs, developing code together.</string>
    <string name="topic4_question30">Pair programming allows programmers to work on their own code independently, trusting the accuracy of each developer.</string>
    <string name="topic4_question31">Scrum is a plan-driven development method that focuses on managing iterative development rather than specific agile practices.</string>
    <string name="topic4_question32">The three phases in Scrum are the initial phase, sprint cycle, and closure phase.</string>
    <string name="topic4_question33">The Scrum Master is responsible for ensuring that the Scrum process is followed and guides the team in the effective use of Scrum.</string>
    <string name="topic4_question34">A Sprint is a development iteration, usually 2-4 weeks long.</string>
    <string name="topic4_question35">Velocity is an estimate of how much product backlog effort that a team can cover in a single sprint.</string>
    <string name="topic4_question36">This is a model of a Scrum sprint cycle:</string>
    <string name="topic4_question37">A downside of a Scrum is the product is broken down into a set of manageable chunks.</string>
    <string name="topic4_question38">A problem with Scrum is unstable requirements hold up progress.</string>
    <string name="topic4_question39">Customers see on-time delivery of increments and gain feedback on how the product works with Scrum.</string>
    <string name="topic4_question40">Scrum allows trust between customers and developers to create a positive culture.</string>
    <string name="quiz_topic4">Agile SW Development</string>
    <string name="quiz_topic5">Software Testing</string>
    <string name="topic5_question1">Testing is NOT intended to show that a program does what it is intended to do.</string>
    <string name="topic5_question2">Program testing can reveal the absence of errors.</string>
    <string name="topic5_question3">Program testing can reveal the presence of errors.</string>
    <string name="topic5_question4">Validation testing demonstrates to the developer and the system customer that the software meets its requirements.</string>
    <string name="topic5_question5">Non-successful defect testing makes the system perform incorrectly to expose a defect in the system.</string>
    <string name="topic5_question6">This is an input-output model of program testing:</string>
    <string name="topic5_question7">Static verification is a software inspection concerned with analysis of the static system representation to discover problems.</string>
    <string name="topic5_question8">Software inspections involve people examining the source code.</string>
    <string name="topic5_question9">An advantage of inspections is not being concerned with interactions between errors.</string>
    <string name="topic5_question10">Inspections and testing should NOT be used during the V and V process.</string>
    <string name="topic5_question11">An effective way to find bugs or faults in software is to try to break it.</string>
    <string name="topic5_question12">In automated testing, a setup part is where you initialize the system with the test case, namely the inputs and expected outputs.</string>
    <string name="topic5_question13">In automated testing, a call part is where you compare the result of the call with the expected result.</string>
    <string name="topic5_question14">The test cases should show that the component you are testing doesn’t do what it is supposed to do.</string>
    <string name="topic5_question15">Partition testing is where you identify groups of inputs that have common characteristics and should be processed in the same way.</string>
    <string name="topic5_question16">With parameter interfaces, blocks of memory are shared between procedures or functions.</string>
    <string name="topic5_question17">With message passing interfaces, subsystems request services from other subsystems.</string>
    <string name="topic5_question18">Timing errors involve the called and called components operating at the same speeds.</string>
    <string name="topic5_question19">Use-cases developed to identify system interactions can be used as a basis for system testing.</string>
    <string name="topic5_question20">A benefit of test-driven development is every code segment written has at least one associated test, so all code is covered.</string>
    <string name="quiz_topic6">Software Testing Techniques</string>
    <string name="topic6_question1">Software testing is not important as reviews and SQA activities are sufficient.</string>
    <string name="topic6_question2">Functional testing involves exercising software requirements.</string>
    <string name="topic6_question3">Structural testing involves testing internal program logic.</string>
    <string name="topic6_question4">The best way to see if your software is fully functional is to trust your developers and their code.</string>
    <string name="topic6_question5">Static analysis and dynamic analysis two types of program analysis.</string>
    <string name="topic6_question6">A bug is a mistake made by the programmer that introduces a fault.</string>
    <string name="topic6_question7">A test driver is a main program that accepts test case data, passes such data to the component and prints relevant results.</string>
    <string name="topic6_question8">A test stub is a collection of software and test data configured to test a program unit by running it under varying conditions and monitoring its behavior.</string>
    <string name="topic6_question9">Functional testing is also known as White box testing.</string>
    <string name="topic6_question10">Gray box testing is testing with both functional and structural techniques.</string>
    <string name="topic6_question11">Beta test is testing products using real users.</string>
    <string name="topic6_question12">System testing is testing whole programs as a system.</string>
    <string name="topic6_question13">Regression testing is testing to approve the acceptance of a system by a client.</string>
    <string name="topic6_question14">Quality assurance and quality control are the same thing.</string>
    <string name="topic6_question15">Verification is an internal process.</string>
    <string name="topic6_question16">Validation goes alongside verification.</string>
    <string name="topic6_question17">This is an example of Quality Assurance vs Quality Control.</string>
    <string name="topic6_question18">Testing schedule is an overall testing schedule and resource allocation for this schedule.</string>
    <string name="topic6_question19">Constraints are required software tools and estimated hardware utilization.</string>
    <string name="topic6_question20">The testing process is not very important in software development.</string>
</resources>