<resources>
    <string name="app_name">QuizAppTest</string>
    <string name="title_message">Software Engineering Study App</string>
    <string name="button_continue">Continue</string>
    <string name="continue_message">Click below to continue</string>
    <string name="button_viewGrades">View Grades</string>
    <string name="button_startsStudying">Start Studying</string>
    <string name="button_startQuiz">Start Quiz</string>
    <string name="blank_string_spacing"></string>
    <string name="quiz_topic2">Software Processes</string>
    <string name="quiz_topic3">Implementation</string>
    <string name="button_true">True</string>
    <string name="button_false">False</string>
    <string name="button_next">Next</string>
    <string name="button_finish">Finish</string>
    <string name="finished_quiz">You have completed all the questions</string>
    <string name="correct_answer_msg">Correct</string>
    <string name="incorrect_answer_msg">Incorrect</string>
    <string name="button_results">See Results</string>
    <string name="quiz_topic1">Introduction</string>
    <string name="topic1_question1">Software engineering is concerned with theories, methods, and tools for professional software development.</string>
    <string name="topic1_question2">Software costs almost never dominate computer system costs. The costs of hardware for a PC are usually greater than the costs of software on a PC.</string>
    <string name="topic1_question3">Software costs more to maintain than to develop, especially for systems with a long life.</string>
    <string name="topic1_question4">Software engineering prioritizes cost-effective software development.</string>
    <string name="topic1_question5">Software projects do not fail because of an increase in system complexity.</string>
    <string name="topic1_question6">Failure to use software engineering methods is a large reason for project failure.</string>
    <string name="topic1_question7">Good attributes of software deliver functionality and performance and should only be semi-maintainable, dependable, and usable.</string>
    <string name="topic1_question8">Fundamental software engineering activities only include software development and software validation</string>
    <string name="topic1_question9">Computer science is concerned with the practicalities of developing software while software engineering focuses on the theories and fundamentals.</string>
    <string name="topic1_question10">System engineering is concerned with all aspects of computer-based systems development including hardware, software, and process engineering while software engineering focuses on the more general process.</string>
    <string name="topic1_question11">Roughly 50% of software costs are development costs, 35% are testing costs, and the remaining 15% costs are miscellaneous.</string>
    <string name="topic1_question12">Stand-alone systems are only marketed to specific customers.</string>
    <string name="topic1_question13">Examples of customized products are embedded control systems, air traffic control software, and traffic monitoring systems.</string>
    <string name="topic1_question14">Generic product software is owned by the developer and customized product software is owned by the customer.</string>
    <string name="topic1_question15">Software should be written in a way that cannot be changed so that it serves its purpose for as long as it is needed.</string>
    <string name="topic1_question16">Dependable software should not cause physical or economic damage in the event of system failure.</string>
    <string name="topic1_question17">Software should use as much of system resources (like memory and processor cycles) in order to be efficient.</string>
    <string name="topic1_question18">Software should be understandable, usable, and compatible with other systems they use.</string>
    <string name="topic1_question19">Software engineering also includes project management and development of tools and methods to support software production.</string>
    <string name="topic1_question20">Software engineers should be able to produce reliable and trustworthy systems economically and quickly</string>
    <string name="topic1_question21">Writing programs as if they were a personal programming project is usually cheaper than software engineering methods.</string>
    <string name="topic1_question22">Software specification is where only the engineers define the software that needs to be produced and the constraints.</string>
    <string name="topic1_question23">Software development is when the software is designed and programmed and software validation is checked to ensure that it is what the customer requires.</string>
    <string name="topic1_question24">Software evolution allows the software to be modified to reflect changing customer and market requirements.</string>
    <string name="topic1_question25">Heterogeneity are systems required to operate as distributed systems across networks that include different types of computer and mobile devices.</string>
    <string name="topic1_question26">Existing software should be erased and replaced as businesses and society changes.</string>
    <string name="topic1_question27">Since software is intertwined with our lives, we must be able to trust that software.</string>
    <string name="topic1_question28">Stand-alone applications run on local computers, but do not include all necessary functionality and need to be connected to a network.</string>
    <string name="topic1_question29">Interactive transaction-based applications execute on remote computers and cannot be accessed by users from their own PCs or terminals.</string>
    <string name="topic1_question30">Entertainment systems are primarily for personal use and are intended to entertain the user.</string>
    <string name="topic1_question31">Systems for modeling and simulation are systems developed by scientists and engineering to model physical processes or situations.</string>
    <string name="topic1_question32">Systems should be developed with the same development process for each type of software.</string>
    <string name="topic1_question33">Never use software that has already been developed and always write new software.</string>
    <string name="topic1_question34">The Web is now a platform for running applications and organizations are increasingly developing web-based systems rather then local systems.</string>
    <string name="topic1_question35">Web-based systems are simple distributed systems and have the same fundamental principles of software engineering that are applied to any other system.</string>
    <string name="topic1_question36">Software reuse is necessary for constructing web-based systems.</string>
    <string name="topic1_question37">Web-systems should be developed and delivered all at one time.</string>
    <string name="topic1_question38">Service-oriented systems develop software components as stand-alone web services.</string>
    <string name="topic1_question39">Software engineering is an engineering discipline concerned with all aspects of software production.</string>
    <string name="topic1_question40">Fundamental notions of software are only applicable to simple types of system development.</string>
    <string name="topic2_question1">Software systems do not require a structured set of activities to be developed.</string>
    <string name="topic2_question2">All software processes involve specification, design and implementation, validation, and evolution.</string>
    <string name="topic2_question3">A software process model is an abstract representation of a process, presenting a description of a process from some particular perspective.</string>
    <string name="topic2_question4">Process descriptions are only about products (outcomes of a process activity).</string>
    <string name="topic2_question5">Plan-driven processes are processes where all of the process activities are planned in advance and progress in measured against the plan.</string>
    <string name="topic2_question6">In agile processes, once the plan is made, changes based on customer requirement are difficult to include.</string>
    <string name="topic2_question7">This is the waterfall method:</string>
    <string name="topic2_question8">The waterfall model is only used for small projects where a system is developed at one site.</string>
    <string name="topic2_question9">Incremental development processes make reducing changing customer requirements difficult.</string>
    <string name="topic2_question10">Customer feedback is easier to get when the development work is done using the incremental development process.</string>
    <string name="topic2_question11">Reuse is now the standard approach for building many types of business systems.</string>
    <string name="topic2_question12">Stand-alone application systems, collections of objects developed as a package, and web services developed to service standards are types of reusable software.</string>
    <string name="topic2_question13">Reusing software means almost no requirement compromises will need to be made for the customer.</string>
    <string name="topic2_question14">Real software processes are interleaved sequences of technical, collaborative, and managerial activities with the overall goal of completing a software system.</string>
    <string name="topic2_question15">These are the requirements of the engineering process:</string>
    <string name="topic2_question16">Software specification establishes what services are required, but constraints are part of the validation process.</string>
    <string name="topic2_question17">Software design is designing and creating specifications into an executable program.</string>
    <string name="topic2_question18">Architecture design is where the overall structure of the systems, the principal components, their relationships, and how they are distributed are identified.</string>
    <string name="topic2_question19">Database design is how to represent a database.</string>
    <string name="topic2_question20">Interface design is where all the data structures and interfaces between system components are designed.</string>
    <string name="topic2_question21">Component selection and design is searching for reusable components.</string>
    <string name="topic2_question22">Programming is a collaborative process with a standard process.</string>
    <string name="topic2_question23">Verification and validation show that a system meets requirements, but disregards customer constraints.</string>
    <string name="topic2_question24">System testing involves executing the system with test cases derived from the specification of the real data to be processed by the system.</string>
    <string name="topic2_question25">Testing stages include data structure testing, component testing, system testing, and customer testing.</string>
    <string name="topic2_question26">Software is inflexible and rarely changeable.</string>
    <string name="topic2_question27">Change is inevitable in all large software projects because of business changes, new technologies, and changing platforms.</string>
    <string name="topic2_question28">Change anticipation includes activities that can anticipate possible changes in software before significant rework is required.</string>
    <string name="topic2_question29">System prototyping is not encouraged because the system is designed quickly in order to check customer requirements.</string>
    <string name="topic2_question30">A prototype is an initial version of a system used to demonstrate concepts and try out design options.</string>
    <string name="topic2_question31">Benefits of prototyping are improved system usability, a closer match to the users’ real needs, improved design quality, improved maintainability, and reduced development effort.</string>
    <string name="topic2_question32">Prototype development should focus only on well-understood areas of the product.</string>
    <string name="topic2_question33">Prototypes should be discarded after development.</string>
    <string name="topic2_question34">Incremental delivery breaks down system delivery into smaller parts with each increment delivering part of the required functionality.</string>
    <string name="topic2_question35">Incremental development is where the system is developed in increments and each increment is evaluated before proceeding to the development of the next increment.</string>
    <string name="topic2_question36">Disadvantages of incremental delivery include difficulty receiving customer value, higher risk of project failure, and low priority system services.</string>
    <string name="topic2_question37">Processes may be structured for iterative development and delivery so that changes may be made without disrupting the system as a whole.</string>
    <string name="topic2_question38">Prototypes should continue to be used after development.</string>
    <string name="topic2_question39">You should not expect to make changes in large software projects.</string>
    <string name="topic2_question40">Component selection and design is coming up with original ideas and implementations for components.</string>
    <string name="topic3_question1">Software design and implementation is the state in software engineering where the executable software is developed.</string>
    <string name="topic3_question2">Structured object-oriented design processes involve developing a number of different system models, but only for small systems developed by different groups due to design models being an important communication mechanism.</string>
    <string name="topic3_question3">Process stages include defining context and modes of the use of the system, designing the system architecture, identifying the principal system objects, developing design models, and specifying object interfaces.</string>
    <string name="topic3_question4">Understanding the relationships between software being designed and its external environment are nonessential; focus should only be placed on the software.</string>
    <string name="topic3_question5">A system context model demonstrates a single system in the environment of the system being developed.</string>
    <string name="topic3_question6">Identifying object classes can be difficult because there is no ‘magic formula’ for object identification.</string>
    <string name="topic3_question7">Base identification on tangible things in the application domain and identify objects based on what participates in what behavior.</string>
    <string name="topic3_question8">Design models only show structural models to describe the static structure in the system in terms of object classes and relationships.</string>
    <string name="topic3_question9">Subsystem models show logical groupings of object into coherent subsystems.</string>
    <string name="topic3_question10">State machine models show the sequence of object states.</string>
    <string name="topic3_question11">Sequence models arrange objects horizontally across the top and time is represented vertically so the models read top to bottom.</string>
    <string name="topic3_question12">This is an example of a sequence diagram:</string>
    <string name="topic3_question13">Subsystem models show how the design is organized into logically related groups of objects.</string>
    <string name="topic3_question14">Other models include use-case models, aggregation models, generalization models.</string>
    <string name="topic3_question15">The following is an example of a state diagram:</string>
    <string name="topic3_question16">Class diagrams show the structure and associate of the classes and list possible state variables and possible interaction methods.</string>
    <string name="topic3_question17">Patterns and pattern languages are ways to describe mediocre practices and designs to help others reuse that experience.</string>
    <string name="topic3_question18">Observer patterns tell one object the state of other objects have changed.</string>
    <string name="topic3_question19">Factory patterns are a creational pattern and deal with object creation.</string>
    <string name="topic3_question20">Facade patterns tidy up unrelated objects that have been developed at the same time.</string>
    <string name="topic3_question21">Iterator patterns provide a standard way of accessing one element in a collection with respect to how that collection is implemented.</string>
    <string name="topic3_question22">Decorator patterns allow for the possibility of extending the functionality of an existing class at run-time.</string>
    <string name="topic3_question23">Design patterns are a way of reusing abstract knowledge about a problem and its solution.</string>
    <string name="topic3_question24">You do not need to recognize patterns in a design problem in order to use patterns in your design.</string>
    <string name="topic3_question25">Creational design patterns engineer a way to create objects rather than creating them directly.</string>
    <string name="topic3_question26">Structural design patterns compose objects to obtain new functionalities.</string>
    <string name="topic3_question27">Behavioral design patterns are concerned with communications of objects and changing their behavior at run time.</string>
    <string name="topic3_question28">The process of object-oriented design is only helpful for designing the system architecture.</string>
    <string name="topic3_question29">A limited range of different models may be produced during an object-oriented design process.</string>
    <string name="topic3_question30">Component interfaces must be defined precisely so that other objects can use them.</string>
</resources>